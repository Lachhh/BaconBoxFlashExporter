<?xml version="1.0"?>
<s:VGroup xmlns:fx="http://ns.adobe.com/mxml/2009" xmlns:s="library://ns.adobe.com/flex/spark">
		<fx:Script><![CDATA[
			import mx.collections.SortField;
			import mx.controls.listClasses.ListItemRenderer;
			import mx.events.PropertyChangeEvent;
			import mx.events.PropertyChangeEventKind;
			import mx.utils.ObjectProxy;
			import mx.utils.object_proxy;

			import spark.collections.Sort;
			import spark.components.supportClasses.ItemRenderer;
			import spark.events.IndexChangeEvent;
			import spark.events.ListEvent;

			private var _lastSelectedDisplayObject:DisplayObject;
			private var _lastSelectedElement:ObjectProxy;
			private var _selectedTextureAtlas:TextureAtlas;

			private function swapSelected(source:List, dest:List):void {
				for each(var index in source.selectedIndices) {
					var item:Object = source.dataProvider.getItemAt(index);
					dest.dataProvider.addItem(item);
				}
				while (source.selectedIndices.length) {
					source.dataProvider.removeItemAt(source.selectedIndices[0]);
				}
			}

			private function updateSelectedTextureAtlas():void {
				selectedTextureAtlas.textureHash.clearDictionary();
				selectedTextureAtlas.symbolHash.clearDictionary();
				for each(var item:Object in symbolList.dataProvider) {
					selectedTextureAtlas.symbolHash.setValue(item.className, item);
				}
				for each(var item:Object in textureList.dataProvider) {
					selectedTextureAtlas.textureHash.setValue(item.className, item);
				}

			}

			private function sortList():void {
				var symbolListProvider:ArrayCollection = (symbolList.dataProvider as ArrayCollection);
				var textureListProvider:ArrayCollection = (textureList.dataProvider as ArrayCollection);
				var nameSortField:SortField = new SortField();
				nameSortField.name = "shortClassName";
				nameSortField.numeric = false;
				var nameSort:Sort = new Sort();
				nameSort.fields = [nameSortField];

				symbolListProvider.sort = nameSort;
				symbolListProvider.refresh();
				textureListProvider.sort = nameSort;

				textureListProvider.refresh();
			}

			private function swapButton_clickHandler(event:MouseEvent):void {
				swapSelected(symbolList, textureList);
				swapSelected(textureList, symbolList);
				symbolList.selectedIndex = -1;
				symbolList.selectedIndex = -1;
				sortList();
				updateSelectedTextureAtlas();
			}

			private function onListChange(event:IndexChangeEvent):void {
				var test:ItemRenderer = (symbolList.dataGroup.getElementAt(0) as ItemRenderer);
				if (event.currentTarget.id == "symbolList") {
					textureList.selectedIndex = -1;
					lastSelectedElement = null;
				}
				else if (event.currentTarget.id == "textureList") {
					symbolList.selectedIndex = -1;
					lastSelectedElement = textureList.selectedItem;
				}

			}

			public function clear():void {
				symbolList.dataProvider = new ArrayCollection();
				textureList.dataProvider = new ArrayCollection();
			}

			[Bindable('selectedDisplayObjectChanged')]
			public function get lastSelectedDisplayObject():DisplayObject {
				return _lastSelectedDisplayObject;
			}

			public function set lastSelectedDisplayObject(value:DisplayObject):void {
				var oldValue:DisplayObject = _lastSelectedDisplayObject;
				_lastSelectedDisplayObject = value;
				dispatchEvent(new PropertyChangeEvent('selectedDisplayObjectChanged',
						false, false, PropertyChangeEventKind.UPDATE,
						'lastSelectedDisplayObject', oldValue, value, this));
			}


			[Bindable('selectedElementChanged')]
			public function get lastSelectedElement():ObjectProxy {
				return _lastSelectedElement;
			}

			public function set lastSelectedElement(value:ObjectProxy):void {
				var oldValue:ObjectProxy = _lastSelectedElement;
				_lastSelectedElement = value;
				dispatchEvent(new PropertyChangeEvent('selectedElementChanged',
						false, false, PropertyChangeEventKind.UPDATE,
						'lastSelectedElement', oldValue, value, this));
			}

			private function onItemRollOut(event:ListEvent):void {
				if (symbolList.selectedItems.length) {
					lastSelectedDisplayObject = new symbolList.selectedItem.classDef;
				}
				else if (textureList.selectedItems.length) {
					lastSelectedDisplayObject = new textureList.selectedItem.classDef;
				}
				else {
					lastSelectedDisplayObject = null;
				}
			}

			public function get selectedTextureAtlas():TextureAtlas {
				return _selectedTextureAtlas;
			}

			public function set selectedTextureAtlas(value:TextureAtlas):void {
				_selectedTextureAtlas = value;
				clear();
				for (var key:String in _selectedTextureAtlas.symbolHash.internalDictionary) {
					symbolList.dataProvider.addItem(_selectedTextureAtlas.symbolHash.getValue(key));
				}
				for (var key:String in _selectedTextureAtlas.textureHash.internalDictionary) {
					textureList.dataProvider.addItem(_selectedTextureAtlas.textureHash.getValue(key));
				}
				sortList();
			}
			]]></fx:Script>
		<s:VGroup width="100%" height="100%">
			<s:Label text="Symbols"></s:Label>
			<s:List id="symbolList" itemRollOut="onItemRollOut(event)" itemRollOver="if(event.item)lastSelectedDisplayObject = new event.item.classDef" itemRenderer="BaconBox.VSwappingSWFElementRenderer" change="onListChange(event)" allowMultipleSelection="true" width="100%" height="100%">
				<s:dataProvider>
				   <s:ArrayCollection id="symbolCollection">

				   </s:ArrayCollection>
				</s:dataProvider>
			</s:List>
		</s:VGroup>

		<s:Button id="swapButton" label="Swap" click="swapButton_clickHandler(event)"></s:Button>

		<s:VGroup width="100%" height="100%">
			<s:Label text="Textures"></s:Label>
			<s:List id="textureList" itemRollOut="onItemRollOut(event)" itemRollOver="if(event.item)lastSelectedDisplayObject = new event.item.classDef" itemRenderer="BaconBox.VSwappingSWFElementRenderer" change="onListChange(event)" allowMultipleSelection="true" width="100%" height="100%">
				<s:dataProvider>
					<s:ArrayCollection id="textureCollection">
					</s:ArrayCollection>
				</s:dataProvider>
			</s:List>
		</s:VGroup>


</s:VGroup>
